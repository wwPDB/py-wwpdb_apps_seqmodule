##
# File:    AlignmentViewDepiction.py
# Date:    20-Apr-2010
#
# Updates:
# 2010-04-20 jdw Ported to module seqmodule.
# 2010-04-20 jdw Separated the rendering modules from AlignView.
# 2010-07-25 RPS Modified so that DB reference sequence types are immutable except for deletions of terminal ranges
# 2010-07-27 RPS Added support for accommodating different ordering of sequence types as per user preferences
# 2010-08-10 RPS Predefined global edits to be effective only for non-DBref sequences
# 2010-08-11 RPS Updated __renderConflictTableOrg so that no longer itemizing gap conflicts
# 2010-10-19 RPS Updated __renderConflictTableOrg so that user is allowed to input annotation details for auth vs. ref discrepancies
##
"""
Controlling class for the production of sequence alignment views.

"""
__docformat__ = "restructuredtext en"
__author__    = "John Westbrook"
__email__     = "jwest@rcsb.rutgers.edu"
__license__   = "Creative Commons Attribution 3.0 Unported"
__version__   = "V0.14"

import sys,copy


from wwpdb.apps.seqmodule.util.SequenceLabel         import SequenceLabel, ResidueLabel, SequenceFeature
from wwpdb.apps.seqmodule.util.SequenceReferenceData import SequenceReferenceData

#
from wwpdb.utils.pair_align.wrapper.libPairwiseAlignPackage import PairwiseAlign, ostream


class AlignmentViewDepiction(object):
    """ Render the input alignment view and conflict table.

    """
    def __init__(self,verbose=False,log=sys.stderr):
        self.__verbose=verbose
        self.__debug=False
        self.__lfh=log

        self.__srd=SequenceReferenceData(verbose=self.__verbose,log=self.__lfh)
        self.__gapSymbol = self.__srd.getGapSymbol()


    def renderAlignment(self,alignSeqList=[],type='original',viewOrderCode='auth-xyz-ref'):
        """Render the input alignment list in HTML according the selected option type.
            RPS, 2010-07-27: 'viewOrderCode' introduced to accommodate user preference
                                for visual ordering of seqtypes in editor
        """
        if (type == "original"):
            return self.__renderAlignmentOrg(alignSeqList,viewOrderCode)
        else:
            return self.__renderAlignmentOrg(alignSeqList,viewOrderCode)

    def renderConflictTable(self,alignSeqList=[],type='original'):
        """Render the conflict table from the input alignment list in HTML according the selected option type.
        """
        if (type == "original"):
            return self.__renderConflictTableOrg(alignSeqList)
        else:
            return self.__renderConflictTableOrg(alignSeqList)

    def __generateSeqListForDisplay(self,alignSeqList,viewOrderCode):
        """ RPS, 2010-07-27: From input alignSeqList generate a local re-ordered copy  
            that satisfies the user preferences for display order
        """
        
        returnList = []
        viewOrderL = viewOrderCode.split("-")
        
        for sqncType in viewOrderL:
            
            for aTup in alignSeqList:
                
                seqLabel = aTup[1]
                (seqType,seqInstId,seqAltId,seqVersion)=seqLabel.get()

                if (seqType == sqncType):
                    returnList.append(aTup)
                    
        return returnList
        
        
        
            
    def __renderAlignmentOrg(self,alignSeqList,viewOrderCode):
        """ Render alignment list in HTML.  (orignal version)

            Returns:

            List of lines of HTML markup.
            
        """

        # verify length consistency -
        #
        alignLength = len(alignSeqList[0][2])
        #
        #
        
        # obtain locally reordered version of alignSeqlist to meet 
        # user preferences for display order
        alignSeqDisplayList = self.__generateSeqListForDisplay(alignSeqList,viewOrderCode)
        #
        resLabel=ResidueLabel()
        alignmentLine=0
        ibeg = 0
        resPerLine = 60
        cssClassPickable="pickable"        
        cssClassSeqLabel="seqLabel"
        cssClassTerminalResidue="trmnlrsdue"

        # contructing reusable legend markup fragment
        legendL=[]
        legendL.append('<ul class="legend">\n<li>|</li>')
        for idx in range(2,resPerLine+1):
            if (idx % 10 == 0):
                legendL.append('<li>|</li>')
            elif (idx % 5 == 0):
                legendL.append('<li>+</li>')                
            else:
                legendL.append('<li>-</li>')                
        legendL.append('</ul>\n')
        # ---
        legend = "".join(legendL)
        #
        outL=[]
        #
        while (ibeg < alignLength):
            #            iend  = min(ibeg + resPerLine, alignLength-1)
            # jdw  - Adjust end condition
            iend  = min(ibeg + resPerLine, alignLength)            
            
            # odd lines -
            if ( alignmentLine % 2 ) :
                cssClassBg="greybg"                
            else:
                cssClassBg="whitebg"                                

            outL.append('<div id="AL%s" class="%s">\n' % ( str(alignmentLine),cssClassBg))

            for aTup in alignSeqDisplayList:
                seqLabel = aTup[1]
                (seqType,seqInstId,seqAltId,seqVersion)=seqLabel.get()

                fD=aTup[4]
                if (seqType == "ref"):   #aD['LABEL']
                    label = fD['DB_NAME'] + ":" + fD['DB_ACCESSION'] + " (" + "R" + str(seqAltId) +  ",V" + str(seqVersion) + ")"
                else:
                    label = seqType.upper() + " PDB:" + seqInstId + " V(" + str(seqVersion) + ")"
                type    = seqType        # aD['TYPE']
                chainId = seqInstId      # aD['CHAIN_ID']
                aL      = aTup[2]        #['ALIGN_LIST']
                cL      = aTup[3]
                polymerTypeCode = fD['POLYMER_TYPE']
                #
                cssClass = type
                #
                idL   =  type +  '_' + chainId + '_' + str(alignmentLine) 
                outL.append('<div id="%s" class="%s">%s &nbsp;</div>\n' % (idL,cssClass,label))
                #
                cssT = cssClassPickable + " " + cssClassBg
                outL.append('<ul id="%s" class="%s">\n' % (idL,cssT))
            
                #outL.append('<ul id="%s">' % idL)                

                for sPos in range(ibeg,iend):
                    rT=aL[sPos]
                    
                    # id contains type(ref,auth,coordinate) + chain_id + 3-letter-code +
                    # orginal residue label index + position in alignment  + position in sequence
                    # type + '_' + chainId + '_' + rT[1] + '_'+ tT[2] + '_' + str(sPos) + '_' + tT[3]
                    #
                    resLabel.set(seqType=seqType, seqInstId=seqInstId, seqAltId=seqAltId, seqVersion=seqVersion,
                                 residueCode3=rT[1], residueLabelIndex=rT[2],
                                 alignIndex=sPos, seqIndex=rT[3], residueType=polymerTypeCode)
                    #
                    idS=resLabel.pack()
                    
                    cssClassType = ""
                    if (polymerTypeCode == "RNA"):
                        cssClassType = " bgcolrna "
                    elif (polymerTypeCode == "DNA"):
                        cssClassType = " bgcoldna "
                    elif (polymerTypeCode == "XNA"):
                        cssClassType = " bgcolrna "
                        if self.__srd.isDNA(rT[1]):
                            cssClassType = " bgcoldna "                            
                    
                    # RPS, 2010-07-16: next block added to prevent database reference sequence from being edited
                    # RPS, 2010-07-25: also using this block to apply special class for "terminal residues" when dealing with database reference sequences
                    # this will allow front-end to allow deletions for any selected ranges in database reference sequences ONLY if the selected
                    # range includes a terminal residue.
                    if( type == "ref" ):
                            cssClassEditable = ""
                    else:
                            cssClassEditable = "dblclick"
                                                        
                    if( type == "ref" and (sPos == 0 or sPos == (alignLength-1) ) ):
                        cssClassEditable += " " + cssClassTerminalResidue

                    if cL[sPos][0] != 0:
                        #cssPosClassBg=cssClassEditable + " bgconflict " +  self.__assignConflictCssStyle(cL[sPos])
                        cssPosClassBg=cssClassEditable + " " +  self.__assignConflictCssStyle(cL[sPos],type)
                        # RPS, 20100810: modified above call to __assignConflictCssStyle to pass seqType                        
                    else:
                        cssPosClassBg=cssClassEditable + cssClassType
                        
                    outL.append('<li id="%s" class="%s">%s</li>' % (idS,cssPosClassBg,rT[0]) )                        
                outL.append('</ul>\n<div class="clearfloat"></div>\n')

            # output legend line - 
            outL.append('<div class="legendcount">%s</div>\n' % str(ibeg+1) )
            outL.append(legend)
            outL.append('<div class="clearfloat"></div>\n')
            outL.append('<br />\n')            
            
            alignmentLine +=1
            ibeg = alignmentLine*resPerLine
            #
            outL.append('</div>\n')
        #
        return outL

    def __renderConflictTableOrg(self,alignSeqList):
        """ Render a summary of all conflicts using the inpu alignment list.

            Storage model - input data as organized in a tuple format used in the 
                            internal alignment list.

            
            Returns:
            
            List of lines of HTML markup for a skeleton table of conflict data.

            Return an empty list if no conflicts are found
            
            # Note - The identifiers associated with residues and details in the conflict
                     table are simply derivable from the residue identifiers used in the
                     alignment depiction.

            
        """
        cssEditDetails="dblclickselect"
        #
        # Get the reference for the alignment and all associated details as #1
        #
        alTup1 =alignSeqList[0]
        #
        seqLabel1  = alTup1[1]
        fD1        = alTup1[4]
        aL1        = alTup1[2]
        cL1        = alTup1[3]        
        (seqType1,seqInstId1,seqAltId1,seqVersion1)=seqLabel1.get()

        if (seqType1 == "ref"):
            label1 = fD1['DB_NAME'] + "<br />" + fD1['DB_ACCESSION']
        else:
            label1 = seqType1.upper() + "<br />PDB:" + seqInstId1

        #
            
        resLabel=ResidueLabel()
        # --------------------
        iCount = 0
        cL=[]
        cL.append('<table id="conflicttable">\n')

        cL.append('<thead>\n')
        cL.append('<tr>\n')
        cL.append('<th>%s</th>' % ("Posi-<br />tion"))
        cL.append('<th>%s</th>' % (label1))
        cL.append('<th>%s</th>' % ("Aligned<br />Sequ-<br />ence"))
        cL.append('<th>%s</th>' % ("Res-<br />idue"))
        cL.append('<th>%s</th>' % ("Annotation<br />Details"))
        cL.append('</tr>\n')
        cL.append('</thead>\n')
        
        cL.append('<tbody>\n')
        for sPos in range(0,len(aL1)):
            rT1=aL1[sPos]
            if cL1[sPos][0] != 0:  # There is some conflict with the current reference sequence -
                # write the residue details for the reference -

                resLabel.set(seqType=seqType1, seqInstId=seqInstId1, seqAltId=seqAltId1, seqVersion=seqVersion1,
                             residueCode3=rT1[1], residueLabelIndex=rT1[2],
                             alignIndex=sPos, seqIndex=rT1[3])
                idS1=resLabel.pack()
                
                for alTup2 in alignSeqList[1:]:
                    #
                    aL2       = alTup2[2]
                    rT2=aL2[sPos]
                    #
                    # RPS, 2010-08-12: added condition to if statement to exclude gap conflicts from listing
                    #if (rT1[1] != rT2[1]) and not ( rT1[1] == self.__gapSymbol or rT2[1] == self.__gapSymbol ):
                    # Any annotated conflict will be include -
                    if (rT1[1] != rT2[1]): 
                        #
                        seqLabel2 = alTup2[1]
                        fD2       = alTup2[4]
                        cL2       = alTup2[3]        
                        (seqType2,seqInstId2,seqAltId2,seqVersion2)=seqLabel2.get()
                        if (seqType2 == "ref"):      
                            label2 = fD2['DB_NAME'] + ":" + fD2['DB_ACCESSION'] + " (" + "R" + str(seqAltId2) +  ",V" + str(seqVersion2) + ")"
                        else:
                            label2 = seqType2.upper() + " PDB:" + seqInstId2 + " (V" + str(seqVersion2) + ")"

                        resLabel.set(seqType=seqType2, seqInstId=seqInstId2, seqAltId=seqAltId2, seqVersion=seqVersion2,
                                     residueCode3=rT2[1], residueLabelIndex=rT2[2],
                                     alignIndex=sPos, seqIndex=rT2[3])
                        idS2=resLabel.pack()
                        #
                        
                        #cL.append('<tr id="%s_R"><td>%d</td>' % (idS2,int(sPos) + 1))
                        cL.append('<tr><td>%d</td>' % (int(sPos) + 1))
                        cL.append('<td><span id="%s_R" class="%s">%s</span></td>' % (idS1,"",rT1[1]) )
                        #
                        cL.append('<td>%s</td>' % label2)                        
                        cL.append('<td>')

                        #
                        # RPS, 20100811: below if-else applied so that DB ref seq types are not editable
                        if( seqType2 == "ref" ):
                            cssEdit=""
                        else:
                            cssEdit="dblclick"
                        #
                        # Add annotation of conflict type via css to this element - 
                        #
                        cssConflict =cssEdit +  " " + self.__assignConflictCssStyle(cL2[sPos],seqType2)
                        # RPS, 20100810: modified above call to __assignConflictCssStyle to pass seqType
                        
                        cL.append('<span id="%s_R" class="%s">%s</span>' % (idS2,cssConflict,rT2[1]) )
                        #
                        #  Close the conflict /td
                        cL.append('</td>')
                        #cL.append('<td><span id="%s_D" class="%s">%s</span></td>' % (idS1,cssEditDetails,rT2[5]) )
                        cL.append('<td><span id="%s_D" class="%s">%s</span></td>' % (idS1,cssEditDetails,rT1[5]) )                        
                        cL.append('</tr>\n')
                        iCount += 1
        #
        cL.append('</tbody>\n</table>\n')
        #
        if iCount > 0:
            return cL
        else:
            return []

    def __assignConflictCssStyle(self,conflictTup,seqType):
        """  Assign a CSS Sytle for the input conflict -
             RPS, 2010-08-10: Updated to accommodate argument for seqType
        """
        styleS=''
        if (conflictTup[0] == 0):
            styleS=''
        elif (conflictTup[0] == 1):
            styleS=" cf-misc-ref "
        elif (conflictTup[0] == 2):
            styleS=" cf-misc-test "

        elif (conflictTup[0] == 3):
            styleS=" cf-gap-test "
        elif (conflictTup[0] == 4):
            styleS=" cf-gap-ref "

        elif (conflictTup[0] == 5):
            styleS=" cf-glu-gln "
        elif (conflictTup[0] == 6):
            styleS=" cf-asp-asn "
        elif (conflictTup[0] == 7):
            styleS=" cf-ala-gly "

        else:
            styleS=''
        
        #RPS, 20100810: applying "cf-rep-<>" only to non-DB ref seq types     
        if ( len(styleS) > 0 ) and (seqType != "ref"):
            styleS+="cf-rep-" + conflictTup[1]
            
        return styleS
