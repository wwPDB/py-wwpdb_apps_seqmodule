##
# File:    AlignmentView.py
# Date:    19-Jan-2010
#
# Updates:
# 20-Apr-2010 jdw Ported to module seqmodule.
# 20-Apr-2010 jdw Move rendering methods to AlignmentViewDepiction.
# 18-May-2010 jdw Add support for 'replaceid' type edits
# 27-Jul-2010 RPS Added support for accommodating different ordering of sequence types as per user preferences
# 11-Aug-2010 RPS Updated doAlignment() and getAlignmentData() to exclude gap conflicts from list of conflicts
# 08-Jan-2013 jdw include leading and trailing conflicts of any type.
##
"""
Controlling class for the production of sequence alignment views.

"""
__docformat__ = "restructuredtext en"
__author__    = "John Westbrook"
__email__     = "jwest@rcsb.rutgers.edu"
__license__   = "Creative Commons Attribution 3.0 Unported"
__version__   = "V0.09"

import sys,copy,traceback

from wwpdb.apps.seqmodule.io.SequenceDataStore         import SequenceDataStore
from wwpdb.apps.seqmodule.io.AlignmentDataStore        import AlignmentDataStore
from wwpdb.apps.seqmodule.io.SequenceEditStore         import SequenceEditStore, SequenceEdit
from wwpdb.apps.seqmodule.align.AlignmentEdit          import getEditStoreFilename
from wwpdb.apps.seqmodule.align.AlignmentStatistics    import AlignmentStatistics
from wwpdb.apps.seqmodule.align.AlignmentViewDepiction import AlignmentViewDepiction

from wwpdb.apps.seqmodule.util.SequenceLabel           import SequenceLabel, ResidueLabel, SequenceFeature
from wwpdb.apps.seqmodule.util.SequenceReferenceData   import SequenceReferenceData

#
from wwpdb.utils.pair_align.wrapper.libPairwiseAlignPackage import PairwiseAlign, ostream


class AlignmentView(object):
    """ Controlling class for the production of sequence alignment views.

        Supported operations:
        
         - load:                align the input sequence list, store and render the alignment.
         - realign:             apply the current set of stored edits and recompute and store the alignment.
         - loadconflictreport:  load the conflict report for the current alignment

            
    """
    def __init__(self,reqObj=None,verbose=False,log=sys.stderr):
        self.__verbose=verbose
        self.__debug=False
        self.__lfh=log
        self.__reqObj=reqObj

        #
        self.__operation  = None
        self.__sessionObj = None
        self.__seqIdList  = []
        self.__alignIdList=[]        
        #
        self.__refSeqId=()
        self.__refSeq  = []        
        self.__refSeqIdx=[]
        self.__refSeqFD={}
        #
        self.__seqList = []        
        self.__alignSeqList=[]
        #
        self.__inputAlignIdList=[]
        #
        self.__alignmentTag=''
        #
        self.__srd=SequenceReferenceData(verbose=self.__verbose,log=self.__lfh)
        self.__gapSymbol = self.__srd.getGapSymbol()
        #
        self.__setup()

    def __setup(self):
        try:
            self.__sessionObj       = self.__reqObj.getSessionObj()
            self.__operation        = self.__reqObj.getAlignmentOp()
            self.__inputAlignIdList = self.__reqObj.getAlignIdList()            
        except:
            pass

    def loadAlign(self):
        """Invoke the particular alignment view operation.
        
        Supported operations:
        
         - load:                align the input sequence list, store and render the alignment.
         - realign:             apply the current set of stored edits and recompute and store the alignment.
         - loadconflictreport:  load the conflict report for the current alignment
         
         """        
        if self.__operation == "realign":
            return self.__updateAndLoad()    
        elif ((self.__operation == "load") or (self.__operation == "loadandstore")):
            return self.__load()
        elif self.__operation == "loadconflictreport":
            avd=AlignmentViewDepiction(self.__verbose,self.__lfh)
            return avd.renderConflictTable(alignSeqList=self.__alignSeqList,type='original')            

    def setAlignmentTag(self,tagValue):
        self.__alignmentTag=tagValue

    def getAlignmentTag(self):
        return self.__alignmentTag

    def renderConflicts(self):
        avd=AlignmentViewDepiction(self.__verbose,self.__lfh)
        return avd.renderConflictTable(alignSeqList=self.__alignSeqList,type='original')                    


    def __load(self):
        """ Using the input sequence list  - get the sequences from the sequence store,
            assign the reference sequence, align the reference with the rest, and store the
            alignment.   
        """
        #
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__load() sessionId %s\n" % self.__sessionObj.getId())
            self.__lfh.write("+AlignmentView.__load() with operation  %s\n" % self.__operation)
            self.__lfh.write("+AlignmentView.__load() input align id list %r\n" %  self.__inputAlignIdList)

        self.__alignIdList=copy.deepcopy(self.__inputAlignIdList)
        self.__getSequenceData()
        self.__doAlignment()
        # save the alignment
        self.__storeAlignmentData()        
        #if (self.__verbose): self.__formatAlignment(sys.stderr)
        avd=AlignmentViewDepiction(self.__verbose,self.__lfh)
        #rps, 28-Aug-2010: argument for 'viewOrderCode' added in call to renderAlignment() to support different ordering
        # of sequence types in alignment editor interface
        oL=avd.renderAlignment(alignSeqList=self.__alignSeqList,type='original',viewOrderCode=self.__reqObj.getAlignmentOrdering() )
        #
        return oL

    def __updateAndLoad(self):    
        #
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__updateAndLoad() with operation %s\n" % self.__operation)
            self.__lfh.write("+AlignmentView.__updateAndLoad() alignment tag %s\n" %  self.__alignmentTag)
            self.__lfh.write("+AlignmentView.__updateAndLoad() align id list %r\n" %  self.__alignIdList)                         
        #
        self.__getAlignmentData()
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__loadandStoreAlignment() recovering alignment ids %d\n" % len(self.__alignIdList))
            for id in self.__alignIdList:
                self.__lfh.write("   id=%s\n" % id)
                
        edIdList=self.__updateAlignment()
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__loadandStoreAlignment() ids edited in this alignment %d\n" % len(edIdList))        
        
        self.__storeAlignmentData()
        #
        revAlignIdList=self.__updateSequences(edIdList)
        

        alstat=AlignmentStatistics(sessionObj=self.__sessionObj,verbose=self.__verbose,log=sys.stderr)
        alstat.doUpdate()
        #
        prevAlignIdList=self.__alignIdList
        self.__alignIdList=revAlignIdList
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__loadandStoreAlignment() updated alignment ids\n")
            for id in self.__alignIdList:
                self.__lfh.write("   id=%s\n" % id)
        #
        # back to the starting state -
        self.__inputAlignIdList = copy.deepcopy(self.__alignIdList)
        oL=self.__load()
        #
        return oL


    ##
    def __getAlignedSequenceIndex(self,id):
        for idx in range(0,len(self.__alignSeqList)):
            if (id == self.__alignSeqList[idx][0]):
                return idx
        return -1

    def __getAlignedSequence(self,id):
        for idx in range(0,len(self.__alignSeqList)):
            if (id == self.__alignSeqList[idx][0]):
                return self.__alignSeqList[idx][2]
        return []

    
    ##
    def __updateSequences(self, seqIdList):
        """ Propogate the alignment edits to new versions of the sequences in the sequence data store.

            Aligned sequences have storage model -
            
            (one-letter-code, 3-letter-code, original label residue index, position in sequence, position in alignment, comment )

             
            Stored sequences have the simpler storage model -

             (3-letter-code, original label residue index, comment/details, alignment index )

            Returns-  a revised list of sequences to be aligned in the next iteration.
                      A copy of self.__alignIdList is updated with any sequence ids
                        updated with new versions in this module.
            
        """
        sLabel=SequenceLabel()
        sFeature=SequenceFeature()
        sds=SequenceDataStore(sessionObj=self.__sessionObj,verbose=self.__verbose, log=self.__lfh)
        #
        oSeqIdList=copy.deepcopy(self.__alignIdList)
        #
        for seqId in seqIdList:
            idxAl=self.__getAlignedSequenceIndex(seqId)
            if (idxAl < 0):
                continue
            #
            # Edited sequence from alignment - 
            alSeqIdx = self.__getAlignedSequence(seqId)
            #
            # Sequence from data store - 
            sLabel.unpack(seqId)
            (seqType,seqInstId,seqAltId,seqVersion)=sLabel.get()
            seqIdx=sds.getSequence(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
            seqFD =sds.getFeature(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
            #
            #
            seqVersion += 1
            seqIdxNext = []
#            if seqType == 'xyz':
            if seqType in ['xyz','auth'] :
                # preserve gaps in coordinate & auth sequences - 
                for aTup in alSeqIdx:
                    seqIdxNext.append((aTup[1],aTup[2],aTup[5],aTup[4]))
            else:  
                #  
                for aTup in alSeqIdx:
                    if aTup[1] != self.__gapSymbol:
                        seqIdxNext.append((aTup[1],aTup[2],aTup[5],aTup[4]))
     
            sds.setSequence(seqIdxNext, seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
            #
            # update the feature dictionary -
            #
            sFeature.set(seqFD)
            sFeature.clearAlignDetails()
            sds.setFeature(sFeature.get(), seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
            #
            # create a new id
            sLabel.set(seqType=seqType,seqInstId=seqInstId,seqAltId=seqAltId,seqVersion=seqVersion)
            seqIdNext=sLabel.pack()
            oSeqIdList.remove(seqId)
            oSeqIdList.append(seqIdNext)
            
        sds.serialize()
        return oSeqIdList
    ##
    def __updateAlignment(self):
        """  Apply any stored edits to the current alignment and update any changed sequences in the sequence store.


             Update the aligned sequences stored as - 
            
             self.__alignSeqList [[Index from sequence data store,
                                  SequenceLabel() object,
                                  aligned sequence with index details,
                                  conflict flag list (bool),
                                  feature dictionary for input sequence],,,]

             Returns - edIdList[] list id's for edited sequences -

             Note -- Currently removing edits after application -
             
        """
        #
        edIdList=[]
        #
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__updateAlignment() operation %s starting\n" % self.__operation)
        #
        esfn=getEditStoreFilename(self.__alignmentTag)
        ses=SequenceEditStore(sessionObj=self.__sessionObj, fileName=esfn,verbose=self.__verbose,log=self.__lfh)
        edObjList=ses.getList()
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__updateAlignment() edit store %s edit list length %d\n" % (esfn,len(edObjList)))
        #
        if (len(edObjList) < 1):
            return edIdList
        #
        resLabel=ResidueLabel()
        #
        # Apply edits to aligned sequences in memory
        #
        # store applied edits for deletion - 
        deleteObjList=[]
        #
        # Find the stored edits associated with each of the aligned sequences and apply these,
        # maintain a list of applied edits so that these may be deleted from the edit store
        # after application.
        #
        for aSeq in self.__alignSeqList:
            id         = aSeq[0]
            aLabel     = aSeq[1]
            aLabel.unpack(id)
            (seqType,seqInstId,seqAltId,seqVersion)=aLabel.get()            
            seqWithIdx = aSeq[2]
            
            if (self.__verbose):
                self.__lfh.write("+AlignmentView.__updateAlignment() searching edits for : seqType %s InstId %s AltId %d seqVersion %d \n"
                                 %  (seqType,seqInstId,seqAltId,seqVersion))
            #
            # Make a list of edit objects for the current aligned sequence.
            #
            eL=[]        
            for edObj in edObjList:
                tId=edObj.getTargetElementId()
                resLabel.unpack(tId)
                (seqTypeEd,seqInstIdEd,seqAltIdEd, seqVersionEd)=resLabel.getSeq()
                #
                #self.__lfh.write("+AlignmentView.__updateAlignment() check edit for seqType %s InstI %s AltId %d seqVersion %d \n"
                #                 %  (seqTypeEd,seqInstIdEd,int(seqAltIdEd),int(seqVersionEd)))                
                if ((seqType==seqTypeEd) and (seqInstId==seqInstIdEd) and (int(seqAltId)==int(seqAltIdEd)) and (int(seqVersion) == int(seqVersionEd))):
                    if (self.__verbose):
                        self.__lfh.write("+AlignmentView.__updateAlignment() matched this edit for sequence tId %s\n" % tId)
                    eL.append(edObj)
            #
            if (self.__verbose):
                self.__lfh.write("+AlignmentView.__updateAlignment() matched %d edits for sequence id %s\n" % (len(eL),id))
                self.__lfh.flush()

            #
            # Apply edits 
            #
            if len(eL) > 0:
                if (self.__verbose):                
                    self.__lfh.write("+AlignmentView.__updateAlignment() id %s sequence length %d edit list length %d\n" %
                                     (id,len(seqWithIdx),len(eL)))
                    self.__lfh.flush()
                aSeq[2]=self.__applyEditsToAlignments(eL,seqWithIdx)
                a3L=[]
                for sPos in aSeq[2]:
                    a3L.append(sPos[1])
                if (self.__verbose):                                    
                    self.__lfh.write("+AlignmentView.__updateAlignment() id %s edited test sequence length %d\n" % (id,len(a3L)) )
                #
                deleteObjList.extend(eL)
                
                edIdList.append(id)

            self.__lfh.flush()

        ses.deleteEditList(deleteObjList)

        return edIdList


    def __applyEditsToAlignments(self,editList, seqWithIndexList):
        """
        Apply edits to the input aligned sequence  - return the edited indexed sequence - 
        
        editList[]          list of edit objects to be applied to indexed input sequence
        
        seqWithIndexList[]  aligned sequence as a list of tuples of  - 
                            (one-letter-code, 3-letter-code, original label residue index, position in sequence, position in alignment, comment )
                            
        Return edited sequence as a list of tuples containing - 
        
           (one-letter-code, 3-letter-code, original label residue index, position in sequence, position in alignment, comment)                     
        """

        resLabel=ResidueLabel()
        #
        # create a list of deletions 
        dList=[]        
        for edObj in editList:
            tId = edObj.getTargetElementId()
            resLabel.unpack(tId)
            iPos=resLabel.getAlignmentIndex()
            if (edObj.getEditType() == 'delete'):            
                dList.append(iPos)
        #        
        for edObj in editList:
            tId     = edObj.getTargetElementId()
            edType  = edObj.getEditType()
            edValue = edObj.getValueNew()
            resLabel.unpack(tId)
            try:
                iPos=int(resLabel.getAlignmentIndex())
            except:
                continue
            if (self.__verbose): self.__lfh.write("+AlignmentView.__applyEditsToAlignments() %s at index %d with %r\n" %
                                                  (edType,iPos,edValue) )

            if (edType == 'replace' or edType == 'insert'):
                edv=" ".join(edValue)
                seqWithIndexList[iPos]=(seqWithIndexList[iPos][0],edv,seqWithIndexList[iPos][2],
                                        seqWithIndexList[iPos][3],iPos,seqWithIndexList[iPos][5])
            elif (edType == 'replaceid'):
                try:
                    newId   = edObj.getNewElementId()                
                    dstLab=ResidueLabel()
                    dstLab.unpack(newId)        
                    dstAlignPos=dstLab.getAlignmentIndex()
                    dstSeqPos  =dstLab.getSequenceIndex()
                    dstLblInd  =dstLab.getResidueLabelIndex()
                    dstResType =dstLab.getResidueType()
                    edv=" ".join(edValue)
                    oneLc=self.__srd.cnv3To1(edv)                                                
                    if (self.__verbose):
                        self.__lfh.write("+AlignmentView.__applyEditsToAlignments() newId %s lbl index %s seq position %s edv %s olc %s\n" %
                                         (newId, dstLblInd, dstSeqPos, edv, oneLc) )
                        self.__lfh.flush()

                    seqWithIndexList[iPos]=(oneLc,edv,dstLblInd,dstSeqPos,iPos,seqWithIndexList[iPos][5])
                except:
                    traceback.print_exc(file=self.__lfh)
                    self.__lfh.flush()
                
            elif (edType == 'details'):
                seqWithIndexList[iPos]=(seqWithIndexList[iPos][0],seqWithIndexList[iPos][1],seqWithIndexList[iPos][2],
                                        seqWithIndexList[iPos][3],iPos,edValue)                


        # Build the edited sequence in seqT[]
        seqT=[]
        insC="ZABCDEFGHIJKLMNOPQRSTUVWXY"
        for idx in range(0,len(seqWithIndexList)):
            # Skip over alignment positions marked for deletion -
            #
            if idx not in dList:
                if (len(seqWithIndexList[idx][1].strip().split()) > 1):
                    tL=seqWithIndexList[idx][1].strip().split()
                    seqT.append((self.__srd.cnv3To1(tL[0]), tL[0], seqWithIndexList[idx][2],seqWithIndexList[idx][3],idx,seqWithIndexList[idx][5]) )
                    for it in range(1,len(tL)):
                        jj = it % len(insC)
                        seqT.append((self.__srd.cnv3To1(tL[it]),tL[it], str(seqWithIndexList[idx][2]) + insC[jj], seqWithIndexList[idx][3],idx,seqWithIndexList[idx][5]))
                else:
                    seqT.append((self.__srd.cnv3To1(seqWithIndexList[idx][1]),seqWithIndexList[idx][1],
                                 seqWithIndexList[idx][2],seqWithIndexList[idx][3],idx,seqWithIndexList[idx][5]))
        #
        #for tup in seqT:
        #    self.__lfh.write("+AlignmentView.__applyEdits() - ed %s - index %s\n" % (tup[0],tup[1]))
        #
        return seqT



    def __getAlignmentStoreFilename(self):
        """ Add a tag to the alignment data filename to differentiate multiple active alignment views. - 
        """
        if (len(self.__alignmentTag)>0):
            fn='alignmentDataStore-'+str(self.__alignmentTag)+'.pic'
        else:
            fn='alignmentDataStore.pic'
        return fn
        
    def __storeAlignmentData(self):
        """  Store the current alignment data in self.__alignSeqList = [[],...]
             in the alignment data store -

             sequence label objects and conflict lists are not saved as these are
             easily updated.
             
        """
        #
        fn=self.__getAlignmentStoreFilename()
        ads=AlignmentDataStore(sessionObj=self.__sessionObj,fileName=fn,verbose=self.__verbose)
        ads.reset()
        idList=[]
        for alSeq in self.__alignSeqList:
            seqId = alSeq[0]
            seqIdxL = alSeq[2]
            seqFD = alSeq[4]
            sLab=SequenceLabel()
            sLab.unpack(seqId)
            (seqType,seqInstId,seqAltId,seqVersion)=sLab.get()
            ads.setSequence(seqIdxL,seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
            ads.setFeature(seqFD,seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
            idList.append(seqId)
        ads.setAlignIdList(idList)
        ads.serialize()

    def __getAlignmentData(self):
        """  Restore the current alignment from the alignment data store -

             Assumes the input has set self.__alignIdList=[]

             Returns the contents in self.__alignSeqList=[] as it was created from
             the previous __doAlignment() call.
             
        """
        fn=self.__getAlignmentStoreFilename()
        ads=AlignmentDataStore(sessionObj=self.__sessionObj,fileName=fn, verbose=self.__verbose)
        self.__alignIdList=ads.getAlignIdList()
        #
        self.__alignSeqList=[]

        #
        # Get alignment reference and ordered list of sequences to align.
        #
        refId,alignIdList=self.__getAlignmentReference()
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__getAlignmentData() alignment length %d\n" % len(self.__alignIdList))            
            self.__lfh.write("+AlignmentView.__getAlignmentData() reference sequence Id (refId) %s\n" % refId)
            self.__lfh.write("+AlignmentView.__getAlignmentData() test id list length   %d\n" % len(alignIdList))
            for id in alignIdList:
                self.__lfh.write("      align Id %s\n" % id)
        #
        refLab=SequenceLabel()
        refLab.unpack(refId)
        (seqType,seqInstId,seqAltId,seqVersion)=refLab.get()
        self.__refAlignSeqIdx=ads.getSequence(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
        self.__refAlignSeqFD =ads.getFeature(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)        
        #
        conflictRefL=[(0,'')]*len(self.__refAlignSeqIdx)                
        self.__alignSeqList.append([refId,refLab,self.__refAlignSeqIdx,conflictRefL,self.__refAlignSeqFD])
        #
        for alignId in alignIdList:
            sLab=SequenceLabel()
            sLab.unpack(alignId)
            (seqType,seqInstId,seqAltId,seqVersion)=sLab.get()
            alSeqIdx=ads.getSequence(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
            alSeqFD =ads.getFeature(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)                    
            conflictL=[(0,'')]*len(alSeqIdx)
            if (self.__verbose):
                self.__lfh.write("\n+AlignmentView.__getAlignmentData() reference %s test  %s  length %d\n"
                                 % (refId, alignId, len(alSeqIdx) ))            
            for idx  in range(0,len(alSeqIdx)):
                # RPS, 2010-08-11: added condition to if statement to exclude gap conflicts
                # JDW, 2013-01-08: include leading and trailing conflicts as expression tags
                if ((self.__refAlignSeqIdx[idx][1] != alSeqIdx[idx][1]) and ( (idx < 25) or (idx > len(alSeqIdx)-25 )) ):
                    conflictL[idx]=self.__assignConflictType(self.__refAlignSeqIdx[idx][1],alSeqIdx[idx][1])
                    conflictRefL[idx]=(1,self.__refAlignSeqIdx[idx][1])
                elif (self.__refAlignSeqIdx[idx][1] != alSeqIdx[idx][1]) and not ( (self.__refAlignSeqIdx[idx][1] == self.__gapSymbol) or (alSeqIdx[idx][1] == self.__gapSymbol) ):
                    conflictL[idx]=self.__assignConflictType(self.__refAlignSeqIdx[idx][1],alSeqIdx[idx][1])
                    conflictRefL[idx]=(1,self.__refAlignSeqIdx[idx][1])

            self.__alignSeqList.append([alignId,sLab,alSeqIdx,conflictL,alSeqFD])


    def __assignConflictType(self,r3Ref,r3Test):
        """ Assign conflict type as  - 

            0 - None
            1 - non-specific in ref sequence
            2 - non-specific in test sequence

            3 - r3Ref = not gap r3Test=gap
            4 - r3Ref = gap     r3Test=not gap
            
            5 - r3Ref = GLU  r3Test = GLN
            6 - r3Ref - ASP  r3Test = ASN

            7 - r3Ref = Any  r3Test = ALA/GLY
            
            and return a tuple of conflict interger type and
            the likely correction.  (code,r3)

        """
        if (r3Ref == r3Test):
            return (0,r3Ref)
        elif (r3Ref != self.__gapSymbol  and r3Test == self.__gapSymbol):
            return (3,r3Ref)
        elif (r3Ref == self.__gapSymbol  and r3Test != self.__gapSymbol):
            return (4,r3Test)
        elif (r3Ref == 'GLU'  and r3Test == 'GLN'):
            return (5,'GLU')
        elif (r3Ref == 'ASP'  and r3Test == 'ASN'):
            return (6,'ASP')
        elif (r3Test == 'ALA' or r3Test == 'GLY'):
            return (7,r3Ref)

        return (2,r3Ref)
        


    def __doAlignment(self):
        """ Align selected sequences against the reference sequence.  Produce a list
            of aligned sequences annotated with index information from the input 
            sequences.

            Data storage model for aligned sequence list - 

            self.__alignSeqList [[Index from sequence data store,
                                  SequenceLabel() object,
                                  aligned sequence with index details,
                                  conflict flag list (bool),
                                  feature dictionary for input sequence],,,]
                                  
        """
        #
        pA=PairwiseAlign()
        pA.setVerbose(self.__verbose)
        pA.setReferenceSequence(self.__refSeq, self.__refSeqId[0])

        for aSeq in self.__seqList:
            pA.addTestSequence(aSeq[2],aSeq[0])
            
        myFails = pA.doAlignConsensus()
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__doAlignment() Consensus failed sequence count = %d\n" % len(myFails))
        
        #
        # Post process the aligned sequences -
        #
        # Get the reference sequence from the first alignment -
        #
        aSeq0=self.__seqList[0]
        aL0=pA.getAlignment(aSeq0[0])
        
        alignRefSeq=[]
        for aTup in aL0:
            alignRefSeq.append(aTup[0])
            
        alignRefSeqIdx=self.__annotateAlignmentWithIndex(alignRefSeq,  self.__refSeqIdx)
        lenRefAlignment=len(alignRefSeqIdx)        
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__doAlignment() First     alignment length for reference %s is %d\n"
                             % (self.__refSeqId[0], len(alignRefSeq)))
            self.__lfh.write("+AlignmentView.__doAlignment() Annotated alignment length for reference %s is %d\n"
                             % (self.__refSeqId[0], len(alignRefSeqIdx)))                

        self.__alignSeqList=[]
        conflictRefL=[(0,'')]*len(aL0)        
        self.__alignSeqList.append([self.__refSeqId[0],self.__refSeqId[1],alignRefSeqIdx,conflictRefL,self.__refSeqFD])

        for aSeq in self.__seqList:
            aL=pA.getAlignment(aSeq[0])
            alignSeq=[]
            conflictL=[(0,'')]*len(aL)
            if (self.__verbose):
                self.__lfh.write("+AlignmentView.__doAlignment() reference %s and test %s length %d\n"
                                 % (self.__refSeqId[0], aSeq[0],len(aL)))            
            ii = 0
            numConflicts=0
            for ii,aTup in enumerate(aL):
                alignSeq.append(aTup[1])
                # RPS, 2010-08-11: added condition to if statement to exclude gap conflicts
                # JDW  2013-01-08  include leading and trailing conflicts of any type
                if ((aTup[0] != aTup[1]) and ( (ii < 20) or ii > (len(aL)-25))):
                    conflictL[ii]=self.__assignConflictType(aTup[0],aTup[1])
                    conflictRefL[ii]=(1,aTup[0])
                    numConflicts+=1                    
                elif (aTup[0] != aTup[1]) and not ( (aTup[0] == self.__gapSymbol) or (aTup[1] == self.__gapSymbol) ):
                    conflictL[ii]=self.__assignConflictType(aTup[0],aTup[1])
                    conflictRefL[ii]=(1,aTup[0])
                    numConflicts+=1
                ii+=1

            if (self.__verbose):
                self.__lfh.write("+AlignmentView.__doAlignment() %s conflicts %d length alignment %d length indexed sequence %d\n"
                                 % (aSeq[0],numConflicts,len(alignSeq),len(aSeq[3])))            
                    
            alignSeqIdx=self.__annotateAlignmentWithIndex(alignSeq,  aSeq[3])
            self.__alignSeqList.append([aSeq[0],aSeq[1],alignSeqIdx,conflictL,aSeq[4]])

        if (self.__verbose):
            for aSeq in self.__seqList:
                self.__lfh.write("+AlignmentView.__doAlignment() %s alignment length %d reference length %d\n" %
                                 (aSeq[0],len(aSeq[2]),lenRefAlignment))
                #pA.wrAlignmentConflicts(ostream(sys.stderr),aSeq[0])
                
            #pA.wrAlignmentFull(ostream(sys.stderr))
            
            numConflicts=0
            for conflictTup in self.__alignSeqList[0][3]:
                if conflictTup[0] != 0:
                    numConflicts+=1
            self.__lfh.write("+AlignmentView.__doAlignment() Total conflicts of all aligned sequences with reference sequence %d\n" % numConflicts)

    def dump(self,io):
        """ Output the original sequence lists and the resulting alignment lists -
        """
        io.write("------------------------------\n")
        io.write("Sequence %s\n" % self.__refSeqId[0] )
        for tup in self.__refSeqIdx:
            io.write("   + %8s %8s %8s \n" % (tup[0],tup[1],tup[2]))

        
        for aSeq in self.__seqList:
            io.write("------------------------------\n")
            io.write("Sequence %s\n" % aSeq[0])
            for tup in aSeq[3]:
                io.write("   + %8s %8s %8s \n" % (tup[0],tup[1],tup[2]))

        io.write("---------  Begin ---------------------\n")
        io.write("Aligned sequences - Aligned sequences - Aligned sequences - Aligned sequences - Aligned sequences  \n")        
        self.__formatAlignment(io)
        io.write("Aligned sequences - Aligned sequences - Aligned sequences - Aligned sequences - Aligned sequences  \n")
        io.write("----------- End -------------------\n")
        io.flush()
        
            
    def __formatAlignment(self,io):
        alignLength = len(self.__alignSeqList[0][2])
        io.write("\n+AlignmentView.__formatAlignment() - Dumping alignment list data - %d\n" % alignLength)
        io.write("                 Key: one-letter-code (3-letter-code) label residue index (position in sequence, position in alignment) conflict\n")
        for aPos in range(0,alignLength):
            io.write("%5d:  " % aPos)            
            for aTup in self.__alignSeqList:
                id=aTup[0]
                sLabel=aTup[1]
                aL=aTup[2]
                conflictL=aTup[3]
                # (one-letter-code, 3-letter-code, original label residue index, position in sequence,position in alignment )
                rT=aL[aPos]
                io.write("%s(%3s) %5s(%5s,%5s)(%r) - " % (rT[0],rT[1],str(rT[2]),str(rT[3]),str(rT[4]),conflictL[aPos][0] ))                
            io.write("\n")
        io.flush()
                
    def __annotateAlignmentWithIndex(self,s3L,s3WithIndexL):
        """
        Input is the aligned sequence as a list of 3-letter-codes or gap-symbols.
    
        Add one-letter code and residue index in the original coordinate sequence and
        returns a list of tuples containing -
                         
        (one-letter-code, 3-letter-code, original label residue index, position in sequence, position in alignment, comment)
        
        """

        ir=0
        annotL=[]
        for idx in range(0,len(s3L)):

            if ((ir < len(s3WithIndexL)) and (s3WithIndexL[ir][0] == s3L[idx])):
                #self.__lfh.write("orgidx-> %s ir %d s3l-> %s  idx %d len s3L %d len s3WithIndexL %d\n" %
                #                 (s3WithIndexL[ir][0],ir,s3L[idx],idx,len(s3L),len(s3WithIndexL)))                
                annotL.append((self.__srd.cnv3To1(s3L[idx]),s3L[idx],s3WithIndexL[ir][1],ir,idx,s3WithIndexL[ir][2]))
                ir += 1
            elif s3L[idx] == self.__gapSymbol:
                annotL.append((self.__gapSymbol,self.__gapSymbol,'','',idx,''))
            else:
                self.__lfh.write("+AlignmentView.__annotateAlignmentWithIndex() error at index %d %s %d %d\n "
                                 % (idx,s3L[idx],ir, len(s3WithIndexL)))
        return annotL



    def __getAlignmentReference(self):
        """
        Select the alignment reference from the input list of sequences.

        self.__alignIdList -  list of id's for alignment -

        return the tuple of the seqId of the reference and the list of test sequences
        
        """

        if len(self.__alignIdList) < 2:
            return (None,[])
        #
        if (self.__verbose):
            self.__lfh.write("\n+AlignmentView.__getAlignmentReference() Alignment ID size - %d\n" % len(self.__alignIdList))
            for id in self.__alignIdList:
                self.__lfh.write("   %s\n" % id)
                
        # take first auth sequence -
        refId=None
        for id in self.__alignIdList:
            if id.startswith("auth"):
                refId=id
                break
        # next try the first ref sequence 
        if refId is None:
            for id in self.__alignIdList:
                if id.startswith("ref"):
                    refId=id
                    break
        # finally - take the first of what is selected - 
        if refId is None:
            refId =self.__alignIdList[0]
        #
        # Order the remainder:  auth, ref, xyz
        #
        oL=[]
        for seqType in ['auth','xyz','ref']:
            for id in self.__alignIdList:
                if id != refId and id.startswith(seqType):
                    oL.append(id)
        if (self.__verbose):
            self.__lfh.write("\n+AlignmentView.__getAlignmentReference() Reference ID  %s\n" % refId)
            for id in oL:
                self.__lfh.write(" Test Id  %s\n" % id)
                
        return refId,oL

    def __getSequenceData(self):
        """
        From the list of input sequences in self.__alignIdList establish the alignment reference and
        the associated test sequences for this alignment.

        Make local copies of the reference sequence identifier and reference sequence and feature
        dictionary - 

        self.__refSeqId = (refId,refLabel)
        self.__refSeqIdx =[(),(),...]
        self.__refFD={}   feature dictionary

        Test sequences are stored  -

        self.__seqList= [[seqId,seqLabelObj,seqL,seqLWithIndex,seqFD]]

        
        """
        #
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__getSequenceData() sessionId %s\n" % self.__sessionObj.getId())
            self.__lfh.write("+AlignmentView.__getSequenceData() with operation:  %s\n" % self.__operation)
        #
        # Get alignment reference and ordered list of sequences to align.
        #
        refId,alignIdList=self.__getAlignmentReference()
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__getSequenceData() reference sequence Id (refId) %s\n" % refId)
        if (self.__debug):
            self.__lfh.write("+AlignmentView.__getSequenceData() test align list length   %d\n" % len(alignIdList))
            for id in alignIdList:
                self.__lfh.write("      test align Id %s\n" % id)
        #
        # 
        sds=SequenceDataStore(sessionObj=self.__sessionObj,verbose=self.__verbose, log=self.__lfh)
        if (self.__debug):
            sds.dump(self.__lfh)

        rLab=SequenceLabel()
        rLab.unpack(refId)
        (seqType,seqInstId,seqAltId,seqVersion)=rLab.get()
        
        self.__refSeqId=(refId,rLab)
        self.__refSeqIdx=sds.getSequence(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
        self.__refSeqFD =sds.getFeature(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)        
        #
        self.__refSeq=[]
        for sPos in self.__refSeqIdx:
            self.__refSeq.append(sPos[0])

        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__getSequenceData() reference sequence Id (refId) %s\n" % refId)
        if (self.__debug):
            self.__lfh.write("+AlignmentView.__getSequenceData() align id list length   %d\n" % len(alignIdList))
            for id in alignIdList:
                self.__lfh.write("      + Alignment test sequence Id %s\n" % id)
        #
        self.__seqList=[]
        for id in alignIdList:
            aLabel = SequenceLabel()            
            aLabel.unpack(id)
            (seqType,seqInstId,seqAltId,seqVersion)=aLabel.get()
            seqIdx=sds.getSequence(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)
            seqFD=sds.getFeature(seqId=seqInstId,seqType=seqType,altId=seqAltId,version=seqVersion)            
            seq=[]
            for sPos in seqIdx:
                seq.append(sPos[0])
            self.__seqList.append([id,aLabel,seq,seqIdx,seqFD])
            if (self.__debug):
                self.__lfh.write("+AlignmentView.__getSequenceData() Saved id %s seqType %s  poly type %s length %d\n" %
                                 (id,seqType,seqFD['POLYMER_TYPE'],len(seqIdx)))
        #
        if (self.__verbose):
            self.__lfh.write("+AlignmentView.__getSequenceData() sequence list length  %d\n" % len(self.__seqList))        
        #
        return True

