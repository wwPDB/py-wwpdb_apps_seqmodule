##
# File:    SequenceDataStore.py
# Date:    14-Jan-2010
#
# Updates:
#   20-Apr-2010 jdw Ported to module seqmodule.
#   04-May-2010 jdw Add methods to capture sequence selections.
#   25-Feb-2013 jdw update documentation
#   27-Feb-2013 jdw replace autoDict with expanded external class Autodict()
##
"""
Provide a storage interface for sequence and sequence feature data for
use by the sequence editing tool.

"""
__docformat__ = "restructuredtext en"
__author__    = "John Westbrook"
__email__     = "jwest@rcsb.rutgers.edu"
__license__   = "Creative Commons Attribution 3.0 Unported"
__version__   = "V0.07"


import sys, cPickle, time, os.path,  pprint, traceback

from wwpdb.apps.seqmodule.util.Autodict  import Autodict

class SequenceDataStore(object):
    """ All sequences are stored as lists and features are stored in dictionaries - 
      - These objects are opaque to this class which only manages their storage.

      Objects are identified by  -

        dataType:  Supported data types are 'sequence' and 'feature'
        seqType:   Sequence types are: auth (author provided), xyz (coordinate),
                   ref (from reference sequence database).
        seqId:     Identifies an instance of a sequence or a feature object within a 
                   sequence type.  Sequence and feature instances are versioned.  This 
                   identifier serves can be a PDB ChainId or the PDBx (_struct_asym.id) 
                   for the author and coordinate sequence types.
        altId:     Distinguishes alternatives associated with a particular sequence
                   instance.   This may be used to support micro-hetereogeneity and
                   alternative reference sequences (default=1)
        version:   integer revision id where 1 is the original version.

        self.__I[dataType][seqType][seqId][altId][version]=((dataId,timeStamp)
        
        self.__D[dataId] = sequence list [...] or  feature dictionary {...} 

        where dataId is a concatenated identifier= seqType_dataType_seqId_altId_version

        Sequence instance groups:

        Identifies groups of related sequence instances. 

        Group Id -> [seqId1, seqId2, ...]

        self.__G[groupId] = [seqId List]

        Sequence id selections:

        self.__S[]= [seqId label list]

        Entry features are stored in a dictoinary of key value pairs. The provides a 
        container for storing features of the entry - 

        self.__E={}
        
    """
    def __init__(self,sessionObj,fileName='sequenceDataStore.pic',verbose=False,log=sys.stderr):
        self.__verbose=verbose
        self.__lfh=log
        self.__sessionObj=sessionObj
        self.__fileName=fileName        
        self.__D={}
        self.__I = Autodict()
        self.__E={}
        self.__G={}
        self.__S=[]
        #
        self.__sessionPath='.'
        self.__filePath=self.__fileName
        #
        #self.__pickleProtocol = cPickle.HIGHEST_PROTOCOL
        self.__pickleProtocol=0
        #
        self.__setup()        

    def __setup(self):
        try:
            self.__sessionPath=self.__sessionObj.getPath()
            self.__filePath = os.path.join(self.__sessionPath,self.__fileName)
            if (self.__verbose):
                self.__lfh.write("+SequenceDataStore.__setup() - session id %s \n" % self.__sessionObj.getId())
                self.__lfh.write("+SequenceDataStore.__setup() - data store path %s\n" % self.__filePath)               

            self.deserialize()
        except:
            self.__lfh.write("+SequenceDataStore.__setup() - Failed to open data store for session id %s data store path %s\n" %
                             (self.__sessionObj.getId(),self.__filePath))            

        
    def reset(self):
        self.__D={}
        self.__I=Autodict()

    def getFilePath(self):
        return self.__filePath
       
    def serialize(self):
        try:
            fb=open(self.__filePath,'wb')
            cPickle.dump(self.__E,fb,self.__pickleProtocol)
            cPickle.dump(self.__G,fb,self.__pickleProtocol)                        
            cPickle.dump(self.__I,fb,self.__pickleProtocol)            
            cPickle.dump(self.__D,fb,self.__pickleProtocol)
            fb.close()
        except:
            if (self.__verbose):
                self.__lfh.write("+SequenceDataStore.__serialize() - failing for %s\n" %   self.__filePath)
                traceback.print_exc(file=self.__lfh)

            
    def deserialize(self):
        try:
            fb=open(self.__filePath,'rb')
            self.__E=cPickle.load(fb)
            self.__G=cPickle.load(fb)
            self.__I=cPickle.load(fb)            
            self.__D=cPickle.load(fb)
            fb.close()
        except:
            if (self.__verbose):
                self.__lfh.write("+SequenceDataStore.__deserialize() - failing for %s\n" %   self.__filePath)
                traceback.print_exc(file=self.__lfh)

    def __makeId(self,dataType,seqType,seqId,altId=1,version=1):
        id="%s_%s_%s_%d_%d" % (dataType,seqType,seqId,altId,version)
        return id

    def __updateIndex(self,id, dataType, seqType,seqId,altId=1,version=1):
        lt = time.strftime("%Y %m %d %H:%M:%S", time.localtime())
        
        self.__I[dataType][seqType][seqId][altId][version]=(id,lt)

    def setSequence(self,sL,seqId,seqType,altId=1,version=1):
        try:
            id=self.__makeId(dataType="sequence", seqType=seqType,seqId=seqId,altId=altId,version=version)
            self.__updateIndex(id, dataType="sequence", seqType=seqType,seqId=seqId,altId=altId,version=version)
            if (sL is None or len(sL) ==0 ):
                if self.__verbose:
                    self.__lfh.write("+SequenceDataStore.__setSequence() - empty object seqId %s seqType %s altId %d version %d\n" %
                                     (seqId,seqType,altId,version))
            self.__D[id]=sL
            return True
        except:
            return False
        
    def getSequence(self,seqId,seqType,altId=1,version=1):
        try:
            id=self.__makeId(dataType="sequence", seqType=seqType,seqId=seqId,altId=altId,version=version)
            return self.__D[id]
        except:
            return []

    def setFeature(self,fD,seqId,seqType,altId=1,version=1):
        try:
            id=self.__makeId(dataType="feature",seqType=seqType,seqId=seqId,altId=altId,version=version)            
            self.__updateIndex(id,dataType="feature",seqType=seqType,seqId=seqId,altId=altId,version=version)
            self.__D[id]=fD
            return True
        except: 
            return False 

    def getFeature(self,seqId,seqType,altId=1,version=1):
        try:
            id=self.__makeId(dataType="feature",seqType=seqType,seqId=seqId,altId=altId,version=version)
            return self.__D[id]
        except:
            return {}
        
    def getSequenceTypes(self,dataType='sequence'):
        try:
            return(self.__I[dataType].keys())
        except:
            return []

    def getSelectedIds(self):
        try:
            return (self.__S)
        except:
            return []

    def addSelectedId(self,id):
        try:
            self.__S.append(id)
            return True
        except:
            return False


    def setSelectedIds(self,idList=[]):
        try:
            self.__S=[]
            self.__S.update(idList)
            return True
        except:
            return False

    def getDataTypes(self):
        try:
            return(self.__I.keys())
        except:
            return []

    def getIds(self, dataType="sequence", seqType="ref"):
        try:
            return(self.__I[dataType][seqType].keys())
        except:
            return []

    def getAlternativeIds(self,seqId, dataType="sequence", seqType="ref"):
        try:
            return(self.__I[dataType][seqType][seqId].keys())
        except:
            return []

    def getVersionIds(self,seqId, altId=1, dataType="sequence", seqType="ref"):
        try:
            vers = self.__I[dataType][seqType][seqId][altId].keys()
            vers.sort(reverse=True)
            return(vers)
        except:
            return []
        
        
    def setGroup(self,groupId,seqIdList=[]):
        try:
            self.__G[groupId]=seqIdList
            return True
        except:
            return False

    def getGroup(self,groupId):
        try:
            return(self.__G[groupId])
        except:
            return []

        self.__G[groupId]=seqIdList        

    def getGroupIds(self):
        try:
            keys = self.__G.keys()
            keys.sort()
            return(keys)
        except:
            return []
        
    def setEntryDetail(self,detailKey,detailValue):
        try:
            self.__E[detailKey]=detailValue
            return True
        except:
            return False

    def getEntryDetail(self,detailKey):
        try:
            return(self.__E[detailKey])
        except:
            return ''

    def dump(self,ofh):
        """  Dump indexes -
        
             self.__I[dataType][seqType][seqId][altId][version]=((dataId,timeStamp)
             
        """
        ofh.write("\nSequence Index:\n")
        for type,v0 in self.__I["sequence"].items():  
            for id,v1 in v0.items():
                for altId, v2 in v1.items():
                    for ver, ival in v2.items():
                        ofh.write("type %5s id %4s ver %2s alt %2d updated %12s seq len %10d\n" %
                                  (type,id,ver,altId,ival[1],len(self.__D[ival[0]]) ))

        ofh.write("\nFeature Index:\n")
        for type,v0 in self.__I['feature'].items():
            for id,v1 in v0.items():
                for altId,v2 in v1.items():
                    for ver, ival in v2.items():                    
                        ofh.write("type %5s id %4s ver  %2s alt %2d updated %12s feat len %10d\n" %
                                  (type,id,ver,altId,ival[1],len(self.__D[ival[0]]) ))
        

        ofh.write("\nSequence Group Index:\n")
        for gId,seqIdList in self.__G.items():
            ofh.write("Sequence group:  %5s\n" % gId)
            for id in seqIdList:
                ofh.write(" %2s" % id)
            ofh.write("\n")
        
        ofh.write("\nEntry Details:\n")
        for k,v in self.__E.items():
            ofh.write("Key:  %10s value: %s\n" % (k,v))

        ofh.write("\nSelected sequences:\n")
        for k in self.__S:
            ofh.write("Sequence ID:  %s\n" % k)            
        #
        #ofh.write("Sequence and Feature Data\n")
        #pprint.pprint(self.__D,stream=ofh)
        
    def dumpData(self,ofh,seqId,seqType,dataType="sequence"):
        altIds = self.__I[dataType][seqType][seqId].keys()
        for altId, vOb in self.__I[dataType][seqType][seqId].items():
            for ver, ival in vOb.items():
                id=self.__makeId(dataType=dataType,seqType=seqType,seqId=seqId,altId=altId,version=ver)            
                ofh.write("Data contents for %10s type %5s id %5s alternative %2d version %2d\n" %
                          (dataType,seqType,seqId,altId,ver))
                if self.__D.has_key(id):
                    pprint.pprint(self.__D[id],stream=ofh)
                else:
                    ofh.write(" NO DATA FOUND\n")
